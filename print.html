<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Git Repo Manager</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="overview.html">Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="tutorial.html"><strong aria-hidden="true">2.</strong> Tutorial</a></li><li class="chapter-item expanded "><a href="repos.html"><strong aria-hidden="true">3.</strong> Managing Repositories</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="local_configuration.html"><strong aria-hidden="true">3.1.</strong> Local Configuration</a></li><li class="chapter-item expanded "><a href="forge_integration.html"><strong aria-hidden="true">3.2.</strong> Forge Integrations</a></li></ol></li><li class="chapter-item expanded "><a href="worktrees.html"><strong aria-hidden="true">4.</strong> Git Worktrees</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="worktree_working.html"><strong aria-hidden="true">4.1.</strong> Working with Worktrees</a></li><li class="chapter-item expanded "><a href="worktree_remotes.html"><strong aria-hidden="true">4.2.</strong> Worktrees and Remotes</a></li><li class="chapter-item expanded "><a href="worktree_behaviour.html"><strong aria-hidden="true">4.3.</strong> Behaviour Details</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">5.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="developing.html"><strong aria-hidden="true">6.</strong> Developer Documentation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="testing.html"><strong aria-hidden="true">6.1.</strong> Testing</a></li><li class="chapter-item expanded "><a href="dependency_updates.html"><strong aria-hidden="true">6.2.</strong> Dependency updates</a></li><li class="chapter-item expanded "><a href="releases.html"><strong aria-hidden="true">6.3.</strong> Releases</a></li><li class="chapter-item expanded "><a href="formatting_and_style.html"><strong aria-hidden="true">6.4.</strong> Formatting & Style</a></li><li class="chapter-item expanded "><a href="documentation.html"><strong aria-hidden="true">6.5.</strong> The Docs Themselves</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Git Repo Manager</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Welcome! This is the documentation for <a href="https://github.com/hakoerber/git-repo-manager/">Git Repo
Manager</a> (GRM for short), a tool
that helps you manage git repositories in a declarative way.</p>
<p>GRM helps you manage git repositories in a declarative way. Configure your
repositories in a TOML or YAML file, GRM does the rest. Take a look at <a href="https://github.com/hakoerber/git-repo-manager/blob/master/example.config.toml">the
example
configuration</a>
to get a feel for the way you configure your repositories. See the <a href="./repos.html">repository
tree chapter</a> for details.</p>
<p>GRM also provides some tooling to work with single git repositories using
<code>git-worktree</code>. See <a href="./worktrees.html">the worktree chapter</a> for more details.</p>
<h2 id="why-use-grm"><a class="header" href="#why-use-grm">Why use GRM?</a></h2>
<p>If you're working with a lot of git repositories, GRM can help you to manage
them in an easy way:</p>
<ul>
<li>You want to easily clone many repositories to a new machine.</li>
<li>You want to change remotes for multiple repositories (e.g. because your GitLab
domain changed).</li>
<li>You want to get an overview over all repositories you have, and check whether
you forgot to commit or push something.</li>
</ul>
<p>If you want to work with <a href="https://git-scm.com/docs/git-worktree">git worktrees</a>
in a streamlined, easy way, GRM provides you with an opinionated workflow. It's
especially helpful when the following describes you:</p>
<ul>
<li>You're juggling a lot of git branches, switching between them a lot.</li>
<li>When switching branches, you'd like to just leave your work as-is, without
using the stash or temporary commits.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Building GRM currently requires the nightly Rust toolchain. The easiest way is
using <a href="https://rustup.rs/"><code>rustup</code></a>. Make sure that rustup is properly
installed.</p>
<p>Make sure that the nightly toolchain is installed:</p>
<pre><code>$ rustup toolchain install nightly
</code></pre>
<p>Then, install the build dependencies:</p>
<table><thead><tr><th>Distribution</th><th>Command</th></tr></thead><tbody>
<tr><td>Arch Linux</td><td><code>pacman -S --needed gcc openssl pkg-config</code></td></tr>
<tr><td>Ubuntu/Debian</td><td><code>apt-get install --no-install-recommends pkg-config gcc libssl-dev zlib1g-dev</code></td></tr>
</tbody></table>
<p>Then, it's a simple command to install the latest stable version:</p>
<pre><code class="language-bash">$ cargo +nightly install git-repo-manager
</code></pre>
<p>If you're brave, you can also run the development build:</p>
<pre><code class="language-bash">$ cargo +nightly install --git https://github.com/hakoerber/git-repo-manager.git --branch develop
</code></pre>
<h2 id="static-build"><a class="header" href="#static-build">Static build</a></h2>
<p>Note that by default, you will get a  dynamically linked executable.
Alternatively, you can also build a statically linked binary. For this, you will
need <code>musl</code> and a few other build dependencies installed installed:</p>
<table><thead><tr><th>Distribution</th><th>Command</th></tr></thead><tbody>
<tr><td>Arch Linux</td><td><code>pacman -S --needed gcc musl perl make</code></td></tr>
<tr><td>Ubuntu/Debian</td><td><code>apt-get install --no-install-recommends gcc musl-tools libc-dev perl make</code></td></tr>
</tbody></table>
<p>(<code>perl</code> and <code>make</code> are required for the OpenSSL build script)</p>
<p>The, add the musl target via <code>rustup</code>:</p>
<pre><code>$ rustup +nightly target add x86_64-unknown-linux-musl
</code></pre>
<p>Then, use a modified build command to get a statically linked binary:</p>
<pre><code>$ cargo +nightly install git-repo-manager --target x86_64-unknown-linux-musl --features=static-build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorial"><a class="header" href="#tutorial">Tutorial</a></h1>
<p>Here, you'll find a quick overview over the most common functionality of GRM.</p>
<h2 id="managing-existing-repositories"><a class="header" href="#managing-existing-repositories">Managing existing repositories</a></h2>
<p>Let's say you have your git repositories at <code>~/code</code>. To start managing them via
GRM, first create a configuration:</p>
<pre><code class="language-bash">grm repos find local ~/code --format yaml &gt; ~/code/config.yml
</code></pre>
<p>The result may look something like this:</p>
<pre><code class="language-yaml">---
trees:
  - root: ~/code
    repos:
      - name: git-repo-manager
        worktree_setup: true
        remotes:
          - name: origin
            url: &quot;https://github.com/hakoerber/git-repo-manager.git&quot;
            type: https
</code></pre>
<p>To apply the configuration and check whether all repositories are in sync, run
the following:</p>
<pre><code class="language-bash">$ grm repos sync config --config ~/code/config.yml
[✔] git-repo-manager: OK
</code></pre>
<p>Well, obiously there are no changes. To check how changes would be applied,
let's change the name of the remote (currently <code>origin</code>):</p>
<pre><code class="language-bash">$ sed -i 's/name: origin/name: github/' ~/code/config.yml
$ grm repos sync config --config ~/code/config.yml
[⚙] git-repo-manager: Setting up new remote &quot;github&quot; to &quot;https://github.com/hakoerber/git-repo-manager.git&quot;
[⚙] git-repo-manager: Deleting remote &quot;origin&quot;
[✔] git-repo-manager: OK
</code></pre>
<p>GRM replaced the <code>origin</code> remote with <code>github</code>.</p>
<p>The configuration (<code>~/code/config.yml</code> in this example) would usually be
something you'd track in git or synchronize between machines via some other
means. Then, on every machine, all your repositories are a single <code>grm repos sync</code> away!</p>
<h2 id="getting-repositories-from-a-forge"><a class="header" href="#getting-repositories-from-a-forge">Getting repositories from a forge</a></h2>
<p>Let's say you have a bunch of repositories on GitHub and you'd like to clone
them all to your local machine.</p>
<p>To authenticate, you'll need to get a personal access token, as described in
<a href="./forge_integration.html#github">the forge documentation</a>. Let's assume you put
your token into <code>~/.github_token</code> (please don't if you're doing this &quot;for
real&quot;!)</p>
<p>Let's first see what kind of repos we can find:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --token-command &quot;cat ~/.github_token&quot; --root ~/code/github.com/ --format yaml
---
trees: []
$
</code></pre>
<p>Ummm, ok? No repos? This is because you have to <em>tell</em> GRM what to look for (if
you don't, GRM will just relax, as it's lazy).</p>
<p>There are different filters (see <a href="./forge_integration.html#filters">the forge
documentation</a> for more info). In our case,
we'll just use the <code>--owner</code> filter to get all repos that belong to us:</p>
<pre><code class="language-bash">$ grm repos find remote --provider github --token-command &quot;cat ~/.github_token&quot; --root ~/code/github.com/ --format yaml
---
trees:
  - root: ~/code/github.com
    repos:
      - name: git-repo-manager
        worktree_setup: false
        remotes:
          - name: origin
            url: &quot;https://github.com/hakoerber/git-repo-manager.git&quot;
            type: https
</code></pre>
<p>Nice! The format is the same as we got from <code>grm repos find local</code> above. So if
we wanted, we could save this file and use it with <code>grm repos sync config</code> as
above. But there is an even easier way: We can directly clone the repositories!</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --token-command &quot;cat ~/.github_token&quot; --root ~/code/github.com/
[⚙] Cloning into &quot;~/code/github.com/git-repo-manager&quot; from &quot;https://github.com/hakoerber/git-repo-manager.git&quot;
[✔] git-repo-manager: Repository successfully cloned
[✔] git-repo-manager: OK
</code></pre>
<p>Nice! Just to make sure, let's run the same command again:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --token-command &quot;cat ~/.github_token&quot; --root ~/code/github.com/
[✔] git-repo-manager: OK
</code></pre>
<p>GRM saw that the repository is already there and did nothing (remember, it's
lazy).</p>
<h2 id="using-worktrees"><a class="header" href="#using-worktrees">Using worktrees</a></h2>
<p>Worktrees are something that make it easier to work with multiple branches at
the same time in a repository.  Let's say we wanted to hack on the codebase of
GRM:</p>
<pre><code class="language-bash">$ cd ~/code/github.com/git-repo-manager
$ ls
.gitignore
Cargo.toml
...
</code></pre>
<p>Well, this is just a normal git repository. But let's try worktrees! First, we
have to convert the existing repository to use the special worktree setup. For
all worktree operations, we will use <code>grm worktree</code> (or <code>grm wt</code> for short):</p>
<pre><code class="language-bash">$ grm wt convert
[✔] Conversion done
$ ls
$
</code></pre>
<p>So, the code is gone? Not really, there is just no active worktree right now. So
let's add one for <code>master</code>:</p>
<pre><code class="language-bash">$ grm wt add master --track origin/master
[✔] Conversion done
$ ls
master
$ (cd ./master &amp;&amp; git status)
On branch master
nothing to commit, working tree clean
</code></pre>
<p>Now, a single worktree is kind of pointless (if we only have one, we could also
just use the normal setup, without worktrees). So let's another one for
<code>develop</code>:</p>
<pre><code class="language-bash">$ grm wt add develop --track origin/develop
[✔] Conversion done
$ ls
develop
master
$ (cd ./develop &amp;&amp; git status)
On branch develop
nothing to commit, working tree clean
</code></pre>
<p>What's the point? The cool thing is that we can now start working in the
<code>develop</code> worktree, without affecting the <code>master</code> worktree at all. If you're
working on <code>develop</code> and want to quickly see what a certain file looks like in
<code>master</code>, just look inside <code>./master</code>, it's all there!</p>
<p>This becomes especially interesting when you have many feature branches and are
working on multiple features at the same time.</p>
<p>There are a lot of options that influence how worktrees are handled. Maybe you
want to automatically track <code>origin/master</code> when you add a worktree called
<code>master</code>?  Maybe you want your feature branches to have a prefix, so when you're
working on the <code>feature1</code> worktree, the remote branch will be
<code>origin/awesomefeatures/feature1</code>? Check out <a href="./worktrees.html">the chapter on
worktrees</a> for all the things that are possible.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-repositories"><a class="header" href="#managing-repositories">Managing Repositories</a></h1>
<p>GRM helps you manage a bunch of git repositories easily. There are generally two
ways to go about that:</p>
<p>You can either manage a list of repositories in a TOML or YAML file, and use GRM
to sync the configuration with the state of the repository.</p>
<p>Or, you can pull repository information from a forge (e.g. GitHub, GitLab) and
clone the repositories.</p>
<p>There are also hybrid modes where you pull information from a forge and create a
configuration file that you can use later.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="local-configuration"><a class="header" href="#local-configuration">Local Configuration</a></h1>
<p>When managing multiple git repositories with GRM, you'll generally have a
configuration file containing information about all the repos you have. GRM then
makes sure that you repositories match that configuration. If they don't exist
yet, it will clone them. It will also make sure that all remotes are configured
properly.</p>
<p>Let's try it out:</p>
<h2 id="get-the-example-configuration"><a class="header" href="#get-the-example-configuration">Get the example configuration</a></h2>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 -sSfO https://raw.githubusercontent.com/hakoerber/git-repo-manager/master/example.config.toml
</code></pre>
<p>Then, you're ready to run the first sync. This will clone all configured
repositories and set up the remotes.</p>
<pre><code class="language-bash">$ grm repos sync config --config example.config.toml
[⚙] Cloning into &quot;/home/me/projects/git-repo-manager&quot; from &quot;https://code.hkoerber.de/hannes/git-repo-manager.git&quot;
[✔] git-repo-manager: Repository successfully cloned
[⚙] git-repo-manager: Setting up new remote &quot;github&quot; to &quot;https://github.com/hakoerber/git-repo-manager.git&quot;
[✔] git-repo-manager: OK
[⚙] Cloning into &quot;/home/me/projects/dotfiles&quot; from &quot;https://github.com/hakoerber/dotfiles.git&quot;
[✔] dotfiles: Repository successfully cloned
[✔] dotfiles: OK
</code></pre>
<p>If you run it again, it will report no changes:</p>
<pre><code>$ grm repos sync config -c example.config.toml
[✔] git-repo-manager: OK
[✔] dotfiles: OK
</code></pre>
<h3 id="generate-your-own-configuration"><a class="header" href="#generate-your-own-configuration">Generate your own configuration</a></h3>
<p>Now, if you already have a few repositories, it would be quite laborious to
write a configuration from scratch. Luckily, GRM has a way to generate a
configuration from an existing file tree:</p>
<pre><code class="language-bash">$ grm repos find local ~/your/project/root &gt; config.toml
</code></pre>
<p>This will detect all repositories and remotes and write them to <code>config.toml</code>.</p>
<h3 id="show-the-state-of-your-projects"><a class="header" href="#show-the-state-of-your-projects">Show the state of your projects</a></h3>
<pre><code class="language-bash">$ grm repos status --config example.config.toml
╭──────────────────┬──────────┬────────┬───────────────────┬────────┬─────────╮
│ Repo             ┆ Worktree ┆ Status ┆ Branches          ┆ HEAD   ┆ Remotes │
╞══════════════════╪══════════╪════════╪═══════════════════╪════════╪═════════╡
│ git-repo-manager ┆          ┆ ✔      ┆ branch: master    ┆ master ┆ github  │
│                  ┆          ┆        ┆ &lt;origin/master&gt; ✔ ┆        ┆ origin  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ dotfiles         ┆          ┆ ✔      ┆                   ┆ Empty  ┆ origin  │
╰──────────────────┴──────────┴────────┴───────────────────┴────────┴─────────╯
</code></pre>
<p>You can also use <code>status</code> without <code>--config</code> to check the repository you're
currently in:</p>
<pre><code>$ cd ~/example-projects/dotfiles
$ grm repos status
╭──────────┬──────────┬────────┬──────────┬───────┬─────────╮
│ Repo     ┆ Worktree ┆ Status ┆ Branches ┆ HEAD  ┆ Remotes │
╞══════════╪══════════╪════════╪══════════╪═══════╪═════════╡
│ dotfiles ┆          ┆ ✔      ┆          ┆ Empty ┆ origin  │
╰──────────┴──────────┴────────┴──────────┴───────┴─────────╯
</code></pre>
<h2 id="yaml"><a class="header" href="#yaml">YAML</a></h2>
<p>By default, the repo configuration uses TOML. If you prefer YAML, just give it a
YAML file instead (file ending does not matter, <code>grm</code> will figure out the
format).  For generating a configuration, pass <code>--format yaml</code> to <code>grm repo find</code> which generates a YAML configuration instead of a TOML configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-integrations"><a class="header" href="#forge-integrations">Forge Integrations</a></h1>
<p>In addition to managing repositories locally, <code>grm</code> also integrates with source
code hosting platforms. Right now, the following platforms are supported:</p>
<ul>
<li><a href="https://github.com/">GitHub</a></li>
<li><a href="https://gitlab.com/">GitLab</a></li>
</ul>
<p>Imagine you are just starting out with <code>grm</code> and want to clone all your
repositories from GitHub. This is as simple as:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --owner --token-command &quot;pass show github_grm_access_token&quot; --path ~/projects
</code></pre>
<p>You will end up with your projects cloned into
<code>~/projects/{your_github_username}/</code></p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>The only currently supported authentication option is using a personal access
token.</p>
<h3 id="github"><a class="header" href="#github">GitHub</a></h3>
<p>See the GitHub documentation for personal access tokens:
<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">Link</a>.</p>
<p>The only required permission is the &quot;repo&quot; scope.</p>
<h3 id="gitlab"><a class="header" href="#gitlab">GitLab</a></h3>
<p>See the GitLab documentation for personal access tokens:
<a href="https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html">Link</a>.</p>
<p>The required scopes are a bit weird. Actually, the following should suffice:</p>
<ul>
<li><code>read_user</code> to get user information (required to get the current
authenticated user name for the <code>--owner</code> filter.</li>
<li>A scope that allows reading private repositories. (<code>read_repository</code> is just
for <em>cloning</em> private repos). This unfortunately does not exist.</li>
</ul>
<p>So currently, you'll need to select the <code>read_api</code> scope.</p>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>By default, <code>grm</code> will sync <strong>nothing</strong>. This is quite boring, so you have to
tell the command what repositories to include. They are all inclusive (i.e. act
as a logical OR), so you can easily chain many filters to clone a bunch of
repositories. It's quite simple:</p>
<ul>
<li><code>--user &lt;USER&gt;</code> syncs all repositories of that remote user</li>
<li><code>--group &lt;GROUP&gt;</code> syncs all repositories of that remote group/organization</li>
<li><code>--owner</code> syncs all repositories of the user that is used for authentication.
This is effectively a shortcut for <code>--user $YOUR_USER</code></li>
<li><code>--access</code> syncs all repositories that the current user has access to</li>
</ul>
<p>Easiest to see in an example:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --user torvals --owner --group zalando [...]
</code></pre>
<p>This would sync all of Torvald's repositories, all of my own repositories and
all (public) repositories in the &quot;zalando&quot; group.</p>
<h2 id="strategies"><a class="header" href="#strategies">Strategies</a></h2>
<p>There are generally three ways how you can use <code>grm</code> with forges:</p>
<h3 id="ad-hoc-cloning"><a class="header" href="#ad-hoc-cloning">Ad-hoc cloning</a></h3>
<p>This is the easiest, there are no local files involved. You just run the
command, <code>grm</code> clones the repos, that's it. If you run the command again, <code>grm</code>
will figure out the differences between local and remote repositories and
resolve them locally.</p>
<h3 id="create-a-file"><a class="header" href="#create-a-file">Create a file</a></h3>
<p>This is effectively <code>grm repos find local</code>, but using the forge instead of the
local file system. You will end up with a normal repository file that you can
commit to git. To update the list of repositories, just run the command again
and commit the new file.</p>
<h3 id="define-options-in-a-file"><a class="header" href="#define-options-in-a-file">Define options in a file</a></h3>
<p>This is a hybrid approach: You define filtering options in a file that you can
commit to source control. Effectively, you are persisting the options you gave
to <code>grm</code> on the command line with the ad-hoc approach. Similarly, <code>grm</code> will
figure out differences between local and remote and resolve them.</p>
<p>A file would look like this:</p>
<pre><code class="language-toml">provider = &quot;github&quot;
token_command = &quot;cat ~/.github_token&quot;
root = &quot;~/projects&quot;

[filters]
owner = true
groups = [
  &quot;zalando&quot;
]
</code></pre>
<p>The options in the file map to the command line options of the <code>grm repos sync remote</code> command.</p>
<p>You'd then run the <code>grm repos sync</code> command the same way as with a list of
repositories in a configuration:</p>
<pre><code class="language-bash">$ grm repos sync --config example.config.toml
</code></pre>
<p>You can even use that file to generate a repository list that you can feed into
<code>grm repos sync</code>:</p>
<pre><code class="language-bash">$ grm repos find config --config example.config.toml &gt; repos.toml
$ grm repos sync config --config repos.toml
</code></pre>
<h2 id="using-with-self-hosted-gitlab"><a class="header" href="#using-with-self-hosted-gitlab">Using with self-hosted GitLab</a></h2>
<p>By default, <code>grm</code> uses the default GitLab API endpoint
(<a href="https://gitlab.com">https://gitlab.com</a>). You can override the endpoint by
specifying the <code>--api-url</code> parameter. Like this:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider gitlab --api-url https://gitlab.example.com [...]
</code></pre>
<h2 id="the-cloning-protocol"><a class="header" href="#the-cloning-protocol">The cloning protocol</a></h2>
<p>By default, <code>grm</code> will use HTTPS for public repositories and SSH otherwise. This
can be overridden with the <code>--force-ssh</code> switch.</p>
<h2 id="about-the-token-command"><a class="header" href="#about-the-token-command">About the token command</a></h2>
<p>To ensure maximum flexibility, <code>grm</code> has a single way to get the token it uses
to authenticate: Specify a command that returns the token via stdout. This
easily integrates with password managers like
<a href="https://www.passwordstore.org/"><code>pass</code></a>.</p>
<p>Of course, you are also free to specify something like <code>echo mytoken</code> as the
command, as long as you are OK with the security implications (like having the
token in clear text in your shell history). It may be better to have the token
in a file instead and read it: <code>cat ~/.gitlab_token</code>.</p>
<p>Generally, use whatever you want. The command just has to return successfully
and return the token as the first line of stdout.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Maybe you just want to locally clone all repos from your GitHub user?</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --owner --root ~/github_projects --token-command &quot;pass show github_grm_access_token&quot;
</code></pre>
<p>This will clone all repositories into
<code>~/github_projects/{your_github_username}</code>.</p>
<p>If instead you want to clone <strong>all</strong> repositories you have access to (e.g. via
organizations or other users' private repos you have access to), just change the
filter a little bit:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --access --root ~/github_projects --token-command &quot;pass show github_grm_access_token&quot;
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="github-1"><a class="header" href="#github-1">GitHub</a></h3>
<p>Unfortunately, GitHub does not have a nice API endpoint to get <strong>private</strong>
repositories for a certain user
(<a href="https://docs.github.com/en/rest/repos/repos#list-repositories-for-a-user"><code>/users/{user}/repos/</code></a>
only returns public repositories).</p>
<p>Therefore, using <code>--user {user}</code> will only show public repositories for GitHub.
Note that this does not apply to <code>--access</code>: If you have access to another
user's private repository, it will be listed.</p>
<h2 id="adding-integrations"><a class="header" href="#adding-integrations">Adding integrations</a></h2>
<p>Adding a new integration involves writing some Rust code. Most of the logic is
generic, so you will not have to reinvent the wheel. Generally, you will need to
gather the following information:</p>
<ul>
<li>A list of repositories for a single user</li>
<li>A list of repositories for a group (or any similar concept if applicable)</li>
<li>A list of repositories for the user that the API token belongs to</li>
<li>The username of the currently authenticated user</li>
</ul>
<p>Authentication currently only works via a bearer token passed via the
<code>Authorization</code> HTTP header.</p>
<p>Each repo has to have the following properties:</p>
<ul>
<li>A name (which also acts as the identifier for diff between local and remote
repositories)</li>
<li>An SSH URL to push to</li>
<li>An HTTPS URL to clone and fetch from</li>
<li>A flag that marks the repository as private</li>
</ul>
<p>If you plan to implement another forge, please first open an issue so we can go
through the required setup. I'm happy to help!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-worktrees"><a class="header" href="#git-worktrees">Git Worktrees</a></h1>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>The default workflow when using git is having your repository in a single
directory.  Then, you can check out a certain reference (usually a branch),
which will update the files in the directory to match the state of that
reference. Most of the time, this is exactly what you need and works perfectly.
But especially when you're working with branches a lot, you may notice that
there is a lot of work required to make everything run smoothly.</p>
<p>Maybe you have experienced the following: You're working on a feature branch.
Then, for some reason, you have to change branches (maybe to investigate some
issue).  But you get the following:</p>
<pre><code>error: Your local changes to the following files would be overwritten by checkout
</code></pre>
<p>Now you can create a temporary commit or stash your changes. In any case, you
have some mental overhead before you can work on something else. Especially with
stashes, you'll have to remember to do a <code>git stash pop</code> before resuming your
work (I cannot count the number of times where I &quot;rediscovered&quot; some code hidden
in some old stash I forgot about). Also, conflicts on a <code>git stash pop</code> are just
horrible.</p>
<p>And even worse: If you're currently in the process of resolving merge conflicts
or an interactive rebase, there is just no way to &quot;pause&quot; this work to check out
a different branch.</p>
<p>Sometimes, it's crucial to have an unchanging state of your repository until
some long-running process finishes. I'm thinking of Ansible and Terraform runs.
I'd rather not change to a different branch while ansible or Terraform are
running as I have no idea how those tools would behave (and I'm not too eager to
find out).</p>
<p>In any case, Git Worktrees are here for the rescue:</p>
<h2 id="what-are-git-worktrees"><a class="header" href="#what-are-git-worktrees">What are git worktrees?</a></h2>
<p><a href="https://git-scm.com/docs/git-worktree">Git Worktrees</a> allow you to have
multiple independent checkouts of your repository on different directories. You
can have multiple directories that correspond to different references in your
repository.  Each worktree has it's independent working tree (duh) and index, so
there is no way to run into conflicts. Changing to a different branch is just a
<code>cd</code> away (if the worktree is already set up).</p>
<h2 id="worktrees-in-grm"><a class="header" href="#worktrees-in-grm">Worktrees in GRM</a></h2>
<p>GRM exposes an opinionated way to use worktrees in your repositories.
Opinionated, because there is a single invariant that makes reasoning about your
worktree setup quite easy:</p>
<p><strong>The branch inside the worktree is always the same as the directory name of the
worktree.</strong></p>
<p>In other words: If you're checking out branch <code>mybranch</code> into a new worktree,
the worktree directory will be named <code>mybranch</code>.</p>
<p>GRM can be used with both &quot;normal&quot; and worktree-enabled repositories. But note
that a single repository can be either the former or the latter. You'll have to
decide during the initial setup which way you want to go for that repository.</p>
<p>If you want to clone your repository in a worktree-enabled way, specify
<code>worktree_setup = true</code> for the repository in your <code>config.toml</code>:</p>
<pre><code class="language-toml">[[trees.repos]]
name = &quot;git-repo-manager&quot;
worktree_setup = true
</code></pre>
<p>Now, when you run a <code>grm sync</code>, you'll notice that the directory of the
repository is empty! Well, not totally, there is a hidden directory called
<code>.git-main-working-tree</code>.  This is where the repository actually &quot;lives&quot; (it's a
bare checkout).</p>
<p>Note that there are few specific things you can configure for a certain
workspace.  This is all done in an optional <code>grm.toml</code> file right in the root of
the worktree. More on that later.</p>
<h2 id="manual-access"><a class="header" href="#manual-access">Manual access</a></h2>
<p>GRM isn't doing any magic, it's just git under the hood. If you need to have
access to the underlying git repository, you can always do this:</p>
<pre><code>$ git --git-dir ./.git-main-working-tree [...]
</code></pre>
<p>This should never be required (whenever you have to do this, you can consider
this a bug in GRM and open an
<a href="https://github.com/hakoerber/git-repo-manager/issues/new">issue</a>, but it may
help in a pinch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="working-with-worktrees"><a class="header" href="#working-with-worktrees">Working with Worktrees</a></h1>
<h2 id="creating-a-new-worktree"><a class="header" href="#creating-a-new-worktree">Creating a new worktree</a></h2>
<p>To actually work, you'll first have to create a new worktree checkout. All
worktree-related commands are available as subcommands of <code>grm worktree</code> (or
<code>grm wt</code> for short):</p>
<pre><code>$ grm wt add mybranch
[✔] Worktree mybranch created
</code></pre>
<p>You'll see that there is now a directory called <code>mybranch</code> that contains a
checkout of your repository, using the branch <code>mybranch</code></p>
<pre><code class="language-bash">$ cd ./mybranch &amp;&amp; git status
On branch mybranch
nothing to commit, working tree clean
</code></pre>
<p>You can work in this repository as usual. Make changes, commit them, revert
them, whatever you're up to :)</p>
<p>Just note that you <em>should</em> not change the branch inside the worktree directory.
There is nothing preventing you from doing so, but you will notice that you'll
run into problems when trying to remove a worktree (more on that later). It may
also lead to confusing behavior, as there can be no two worktrees that have the
same branch checked out. So if you decide to use the worktree setup, go all in,
let <code>grm</code> manage your branches and bury <code>git branch</code> (and <code>git checkout -b</code>).</p>
<p>You will notice that there is no tracking branch set up for the new branch. You
can of course set up one manually after creating the worktree, but there is an
easier way, using the <code>--track</code> flag during creation. Let's create another
worktree. Go back to the root of the repository, and run:</p>
<pre><code class="language-bash">$ grm wt add mybranch2 --track origin/mybranch2
[✔] Worktree mybranch2 created
</code></pre>
<p>You'll see that this branch is now tracking <code>mybranch</code> on the <code>origin</code> remote:</p>
<pre><code class="language-bash">$ cd ./mybranch2 &amp;&amp; git status
On branch mybranch

Your branch is up to date with 'origin/mybranch2'.
nothing to commit, working tree clean
</code></pre>
<p>The behavior of <code>--track</code> differs depending on the existence of the remote
branch:</p>
<ul>
<li>If the remote branch already exists, <code>grm</code> uses it as the base of the new
local branch.</li>
<li>If the remote branch does not exist (as in our example), <code>grm</code> will create a
new remote tracking branch, using the default branch (either <code>main</code> or
<code>master</code>) as the base</li>
</ul>
<p>Often, you'll have a workflow that uses tracking branches by default. It would
be quite tedious to add <code>--track</code> every single time. Luckily, the <code>grm.toml</code>
file supports defaults for the tracking behavior. See this for an example:</p>
<pre><code class="language-toml">[track]
default = true
default_remote = &quot;origin&quot;
</code></pre>
<p>This will set up a tracking branch on <code>origin</code> that has the same name as the
local branch.</p>
<p>Sometimes, you might want to have a certain prefix for all your tracking
branches.  Maybe to prevent collisions with other contributors. You can simply
set <code>default_remote_prefix</code> in <code>grm.toml</code>:</p>
<pre><code class="language-toml">[track]
default = true
default_remote = &quot;origin&quot;
default_remote_prefix = &quot;myname&quot;
</code></pre>
<p>When using branch <code>my-feature-branch</code>, the remote tracking branch would be
<code>origin/myname/my-feature-branch</code> in this case.</p>
<p>Note that <code>--track</code> overrides any configuration in <code>grm.toml</code>. If you want to
disable tracking, use <code>--no-track</code>.</p>
<h2 id="showing-the-status-of-your-worktrees"><a class="header" href="#showing-the-status-of-your-worktrees">Showing the status of your worktrees</a></h2>
<p>There is a handy little command that will show your an overview over all
worktrees in a repository, including their status (i.e. changes files). Just run
the following in the root of your repository:</p>
<pre><code>$ grm wt status
╭───────────┬────────┬──────────┬──────────────────╮
│ Worktree  ┆ Status ┆ Branch   ┆ Remote branch    │
╞═══════════╪════════╪══════════╪══════════════════╡
│ mybranch  ┆ ✔      ┆ mybranch ┆                  │
│ mybranch2 ┆ ✔      ┆ mybranch ┆ origin/mybranch2 │
╰───────────┴────────┴──────────┴──────────────────╯
</code></pre>
<p>The &quot;Status&quot; column would show any uncommitted changes (new / modified / deleted
files) and the &quot;Remote branch&quot; would show differences to the remote branch (e.g.
if there are new pushes to the remote branch that are not yet incorporated into
your local branch).</p>
<h2 id="deleting-worktrees"><a class="header" href="#deleting-worktrees">Deleting worktrees</a></h2>
<p>If you're done with your worktrees, use <code>grm wt delete</code> to delete them. Let's
start with <code>mybranch2</code>:</p>
<pre><code>$ grm wt delete mybranch2
[✔] Worktree mybranch2 deleted
</code></pre>
<p>Easy. On to <code>mybranch</code>:</p>
<pre><code>$ grm wt delete mybranch
[!] Changes in worktree: No remote tracking branch for branch mybranch found. Refusing to delete
</code></pre>
<p>Hmmm. <code>grm</code> tells you:</p>
<p>&quot;Hey, there is no remote branch that you could have pushed your changes to. I'd
rather not delete work that you cannot recover.&quot;</p>
<p>Note that <code>grm</code> is very cautious here. As your repository will not be deleted,
you could still recover the commits via
<a href="https://git-scm.com/docs/git-reflog"><code>git-reflog</code></a>.  But better safe than
sorry! Note that you'd get a similar error message if your worktree had any
uncommitted files, for the same reason. Now you can either commit &amp; push your
changes, or your tell <code>grm</code> that you know what you're doing:</p>
<pre><code>$ grm wt delete mybranch --force
[✔] Worktree mybranch deleted
</code></pre>
<p>If you just want to delete all worktrees that do not contain any changes, you
can also use the following:</p>
<pre><code>$ grm wt clean
</code></pre>
<p>Note that this will not delete the default branch of the repository. It can of
course still be delete with <code>grm wt delete</code> if necessary.</p>
<h3 id="converting-an-existing-repository"><a class="header" href="#converting-an-existing-repository">Converting an existing repository</a></h3>
<p>It is possible to convert an existing directory to a worktree setup, using <code>grm wt convert</code>. This command has to be run in the root of the repository you want
to convert:</p>
<pre><code>$ grm wt convert
[✔] Conversion successful
</code></pre>
<p>This command will refuse to run if you have any changes in your repository.
Commit them and try again!</p>
<p>Afterwards, the directory is empty, as there are no worktrees checked out yet.
Now you can use the usual commands to set up worktrees.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="worktrees-and-remotes"><a class="header" href="#worktrees-and-remotes">Worktrees and Remotes</a></h1>
<p>To fetch all remote references from all remotes in a worktree setup, you can use
the following command:</p>
<pre><code>$ grm wt fetch
[✔] Fetched from all remotes
</code></pre>
<p>This is equivalent to running <code>git fetch --all</code> in any of the worktrees.</p>
<p>Often, you may want to pull all remote changes into your worktrees. For this,
use the <code>git pull</code> equivalent:</p>
<pre><code>$ grm wt pull
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>This will refuse when there are local changes, or if the branch cannot be fast
forwarded. If you want to rebase your local branches, use the <code>--rebase</code> switch:</p>
<pre><code>$ grm wt pull --rebase
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>As noted, this will fail if there are any local changes in your worktree. If you
want to stash these changes automatically before the pull (and unstash them
afterwards), use the <code>--stash</code> option.</p>
<p>This will rebase your changes onto the upstream branch. This is mainly helpful
for persistent branches that change on the remote side.</p>
<p>There is a similar rebase feature that rebases onto the <strong>default</strong> branch
instead:</p>
<pre><code>$ grm wt rebase
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>This is super helpful for feature branches. If you want to incorporate changes
made on the remote branches, use <code>grm wt rebase</code> and all your branches will be
up to date. If you want to also update to remote tracking branches in one go,
use the <code>--pull</code> flag, and <code>--rebase</code> if you want to rebase instead of aborting
on non-fast-forwards:</p>
<pre><code>$ grm wt rebase --pull --rebase
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>&quot;So, what's the difference between <code>pull --rebase</code> and <code>rebase --pull</code>? Why the
hell is there a <code>--rebase</code> flag in the <code>rebase</code> command?&quot;</p>
<p>Yes, it's kind of weird. Remember that <code>pull</code> only ever updates each worktree to
their remote branch, if possible. <code>rebase</code> rebases onto the <strong>default</strong> branch
instead. The switches to <code>rebase</code> are just convenience, so you do not have to
run two commands.</p>
<ul>
<li><code>rebase --pull</code> is the same as <code>pull</code> &amp;&amp; <code>rebase</code></li>
<li><code>rebase --pull --rebase</code> is the same as <code>pull --rebase</code> &amp;&amp; <code>rebase</code></li>
</ul>
<p>I understand that the UX is not the most intuitive. If you can think of an
improvement, please let me know (e.g. via an GitHub issue)!</p>
<p>As with <code>pull</code>, <code>rebase</code> will also refuse to run when there are changes in your
worktree. And you can also use the <code>--stash</code> option to stash/unstash changes
automatically.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="behavior-details"><a class="header" href="#behavior-details">Behavior Details</a></h1>
<p>When working with worktrees and GRM, there is a lot going on under the hood.
Each time you create a new worktree, GRM has to figure out what commit to set
your new branch to and how to configure any potential remote branches.</p>
<p>To state again, the most important guideline is the following:</p>
<p><strong>The branch inside the worktree is always the same as the directory name of the
worktree.</strong></p>
<p>The second set of guidelines relates to the commit to check out, and the remote
branches to use:</p>
<ul>
<li>When a branch already exists, you will get a worktree for that branch</li>
<li>Existing local branches are never changed</li>
<li>Only do remote operations if specifically requested (via configuration file or
command line parameters)</li>
<li>When you specify <code>--track</code>, you will get that exact branch as the tracking
branch</li>
<li>When you specify <code>--no-track</code>, you will get no tracking branch</li>
</ul>
<p>Apart from that, GRM tries to do The Right Thing<sup>TM</sup>. It should be as
little surprising as possible.</p>
<p>In 99% of the cases, you will not have to care about the details, as the normal
workflows are covered by the rules above. In case you want to know the exact
behavior &quot;specification&quot;, take a look at the <a href="https://docs.rs/git-repo-manager/latest/grm/worktree/index.html">module documentation for
<code>grm::worktree</code></a>.</p>
<p>If you think existing behavior is super-duper confusing and you have a better
idea, do not hesitate to open a GitHub issue to discuss this!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>Currently empty, as there are no questions that are asked frequently :D</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>GRM is still in very early development. I started GRM mainly to scratch my own
itches (and am heavily dogfooding it). If you have a new use case for GRM, go
for it!</p>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p>To contribute, just fork the repo and create a pull request against <code>develop</code>.
If you plan bigger changes, please consider opening an issue first, so we can
discuss it.</p>
<p>If you want, add yourself to the <code>CONTRIBUTORS</code> file in your pull request.</p>
<h2 id="branching-strategy"><a class="header" href="#branching-strategy">Branching strategy</a></h2>
<p>The branching strategy is a simplified
<a href="https://nvie.com/posts/a-successful-git-branching-model/">git-flow</a>.</p>
<ul>
<li><code>master</code> is the &quot;production&quot; branch. Each commit is a new release.</li>
<li><code>develop</code> is the branch where new stuff is coming in.</li>
<li>feature branches branch off of <code>develop</code> and merge back into it.</li>
</ul>
<p>Feature branches are not required, there are also changes happening directly on
<code>develop</code>.</p>
<h2 id="required-tooling"><a class="header" href="#required-tooling">Required tooling</a></h2>
<p>You will need the following tools:</p>
<ul>
<li>Rust (obviously) (easiest via <code>rustup</code>), with the nightly toolchain</li>
<li>Python3</li>
<li><a href="https://github.com/casey/just"><code>just</code></a>, a command runner like <code>make</code>. See
<a href="https://github.com/casey/just#installation">here</a> for installation
instructions (it's most likely just a simple <code>cargo install just</code>).</li>
<li>Docker &amp; docker-compose for the e2e tests</li>
<li><code>black</code> and <code>shfmt</code> for formatting.</li>
<li><code>shellcheck</code> for shell script linting</li>
<li><code>mdbook</code> for the documentation</li>
</ul>
<p>Here are the tools:</p>
<table><thead><tr><th>Distribution</th><th>Command</th></tr></thead><tbody>
<tr><td>Arch Linux</td><td><code>pacman -S --needed python3 rustup just docker docker-compose python-black shfmt shellcheck mdbook</code></td></tr>
<tr><td>Ubuntu/Debian</td><td><code>apt-get install --no-install-recommends python3 docker.io docker-compose black shellcheck</code></td></tr>
</tbody></table>
<p>Note that you will have to install <code>just</code> and <code>mdbook</code> manually on Ubuntu (e.g.
via <code>cargo install just mdbook</code> if your rust build environment is set up
correctly). Same for <code>shfmt</code>, which may just be a <code>go install mvdan.cc/sh/v3/cmd/shfmt@latest</code>, depending on your go build environment.</p>
<p>For details about rustup and the toolchains, see <a href="./installation.html">the installation
section</a>.</p>
<h2 id="faq-1"><a class="header" href="#faq-1">FAQ</a></h2>
<h3 id="why-nightly"><a class="header" href="#why-nightly">Why nightly?</a></h3>
<p>For now, GRM requires the nightly toolchain for two reasons:</p>
<ul>
<li><a href="https://github.com/rust-lang/rust/issues/86442"><code>io_error_more</code></a> to get
better error messages on IO errors</li>
<li><a href="https://github.com/rust-lang/rust/issues/91930"><code>const_option_ext</code></a> to have
static variables read from the environment that fall back to hard coded
defaults</li>
</ul>
<p>Honestly, both of those are not really necessary or can be handled without
nightly. It's just that I'm using nightly anyway.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing"><a class="header" href="#testing">Testing</a></h1>
<p>There are two distinct test suites: One for unit test (<code>just test-unit</code>) and
integration tests (<code>just test-integration</code>) that is part of the rust crate, and
a separate e2e test suite in python (<code>just test-e2e</code>).</p>
<p>To run all tests, run <code>just test</code>.</p>
<p>When contributing, consider whether it makes sense to add tests which could
prevent regressions in the future. When fixing bugs, it makes sense to add tests
that expose the wrong behavior beforehand.</p>
<p>The unit and integration tests are very small and only test a few self-contained
functions (like validation of certain input).</p>
<h2 id="e2e-tests"><a class="header" href="#e2e-tests">E2E tests</a></h2>
<p>The main focus of the testing setup lays on the e2e tests. Each user-facing
behaviour <em>should</em> have a corresponding e2e test. These are the most important
tests, as they test functionality the user will use in the end.</p>
<p>The test suite is written in python and uses
<a href="https://docs.pytest.org/en/stable/">pytest</a>. There are helper functions that
set up temporary git repositories and remotes in a <code>tmpfs</code>.</p>
<p>Effectively, each tests works like this:</p>
<ul>
<li>Set up some prerequisites (e.g. different git repositories or configuration
files)</li>
<li>Run <code>grm</code></li>
<li>Check that everything is according to expected behaviour (e.g. that <code>grm</code> had
certain output and exit code, that the target repositories have certain
branches, heads and remotes, ...)</li>
</ul>
<p>As there are many different scenarios, the tests make heavy use of the
<a href="https://docs.pytest.org/en/stable/how-to/parametrize.html#pytest-mark-parametrize"><code>@pytest.mark.parametrize</code></a>
decorator to get all permutations of input parameters (e.g. whether a
configuration exists, what a config value is set to, how the repository looks
like, ...)</p>
<p>Whenever you write a new test, think about the different circumstances that can
happen. What are the failure modes? What affects the behaviour? Parametrize each
of these behaviours.</p>
<h3 id="optimization"><a class="header" href="#optimization">Optimization</a></h3>
<p>Note: You will most likely not need to read this.</p>
<p>Each test parameter will exponentially increase the number of tests that will be
run. As a general rule, comprehensiveness is more important than test suite
runtime (so if in doubt, better to add another parameter to catch every edge
case). But try to keep the total runtime sane. Currently, the whole <code>just e2e</code>
target runs ~8'000 tests and takes around 5 minutes on my machine, exlucding
binary and docker build time. I'd say that keeping it under 10 minutes is a good
idea.</p>
<p>To optimize tests, look out for two patterns: Dependency and Orthogonality</p>
<h4 id="dependency"><a class="header" href="#dependency">Dependency</a></h4>
<p>If a parameter depends on another one, it makes little sense to handle them
independently. Example: You have a paramter that specifies whether a
configuration is used, and another parameter that sets a certain value in that
configuration file. It might look something like this:</p>
<pre><code class="language-python">@pytest.mark.parametrize(&quot;use_config&quot;, [True, False])
@pytest.mark.parametrize(&quot;use_value&quot;, [&quot;0&quot;, &quot;1&quot;])
def test(...):
</code></pre>
<p>This leads to 4 tests being instantiated. But there is little point in setting a
configuration value when no config is used, so the combinations <code>(False, &quot;0&quot;)</code>
and <code>(False, &quot;1&quot;)</code> are redundant. To remedy this, spell out the optimized
permutation manually:</p>
<pre><code class="language-python">@pytest.mark.parametrize(&quot;config&quot;, ((True, &quot;0&quot;), (True, &quot;1&quot;), (False, None)))
def test(...):
    (use_config, use_value) = config
</code></pre>
<p>This cuts down the number of tests by 25%. If you have more dependent parameters
(e.g. additional configuration values), this gets even better.  Generally, this
will cut down the number of tests to</p>
<p>\[ \frac{1}{o \cdot c} + \frac{1}{(o \cdot c) ^ {(n + 1)}} \]</p>
<p>with \( o \) being the number of values of a parent parameters a parameter is
dependent on, \( c \) being the cardinality of the test input (so you can
assume \( o = 1 \) and \( c = 2 \) for boolean parameters), and \( n \)
being the number of parameters that are optimized, i.e. folded into their
dependent parameter.</p>
<p>As an example: Folding down two boolean parameters into one dependent parent
boolean parameter will cut down the number of tests to 62.5%!</p>
<h4 id="orthogonality"><a class="header" href="#orthogonality">Orthogonality</a></h4>
<p>If different test parameters are independent of each other, there is little
point in testing their combinations. Instead, split them up into different test
functions. For boolean parameters, this will cut the number of tests in half.</p>
<p>So instead of this:</p>
<pre><code class="language-python">@pytest.mark.parametrize(&quot;param1&quot;, [True, False])
@pytest.mark.parametrize(&quot;param2&quot;, [True, False])
def test(...):
</code></pre>
<p>Rather do this:</p>
<pre><code class="language-python">@pytest.mark.parametrize(&quot;param1&quot;, [True, False])
def test_param1(...):

@pytest.mark.parametrize(&quot;param2&quot;, [True, False])
def test_param2(...):
</code></pre>
<p>The tests are running in Docker via docker-compose. This is mainly needed to
test networking functionality like GitLab integration, with the GitLab API being
mocked by a simple flask container.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dependency-updates"><a class="header" href="#dependency-updates">Dependency updates</a></h1>
<p>Rust has the same problem as the node ecosystem, just a few magnitudes smaller:
Dependency sprawl. GRM has a dozen direct dependencies, but over 150 transitive
ones.</p>
<p>To keep them up to date, there is a script:
<code>depcheck/update-cargo-dependencies.py</code>. It updates direct dependencies to the
latest stable version and updates transitive dependencies where possible. To run
it, use <code>just update-dependencies</code>, which will create commits for each update.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="releases"><a class="header" href="#releases">Releases</a></h1>
<p>To make a release, make sure you are on a clean <code>develop</code> branch, sync your
remotes and then run <code>./release (major|minor|patch)</code>. It will handle a
git-flow-y release, meaning that it will perform a merge from <code>develop</code> to
<code>master</code>, create a git tag, sync all remotes and run <code>cargo publish</code>.</p>
<p>Make sure to run <code>just check</code> before releasing to make sure that nothing is
broken.</p>
<p>As GRM is still <code>v0.x</code>, there is not much consideration for backwards
compatibility. Generally, update the patch version for small stuff and the minor
version for bigger / backwards incompatible changes.</p>
<p>Generally, it's good to regularly release a new patch release with <a href="./dependency_updates.html">updated
dependencies</a>. As <code>./release.sh patch</code> is exposed as a
Justfile target (<code>release-patch</code>), it's possible to do both in one step:</p>
<pre><code class="language-bash">$ just update-dependencies check release-patch
</code></pre>
<h2 id="release-notes"><a class="header" href="#release-notes">Release notes</a></h2>
<p>There are currently no release notes. Things are changing quite quickly and
there is simply no need for a record of changes (except the git history of
course).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatting--style"><a class="header" href="#formatting--style">Formatting &amp; Style</a></h1>
<h2 id="code-formatting"><a class="header" href="#code-formatting">Code formatting</a></h2>
<p>I'm allergic to discussions about formatting. I'd rather make the computer do it
for me.</p>
<p>For Rust, just use <code>cargo fmt</code>. For Python, use
<a href="https://github.com/psf/black">black</a>. I'd rather not spend any effort in
configuring the formatters (not possible for black anyway). For shell scripts,
use <a href="https://github.com/mvdan/sh"><code>shfmt</code></a>.</p>
<p>To autoformat all code, use <code>just fmt</code></p>
<h2 id="style"><a class="header" href="#style">Style</a></h2>
<p>Honestly, no idea about style. I'm still learning Rust, so I'm trying to find a
good style. Just try to keep it consistent when you add code.</p>
<h2 id="linting"><a class="header" href="#linting">Linting</a></h2>
<p>You can use <code>just lint</code> to run all lints.</p>
<h3 id="rust"><a class="header" href="#rust">Rust</a></h3>
<p>Clippy is the guard that prevents shitty code from getting into the code base.
When running <code>just check</code>, any clippy suggestions will make the command fail.
So make clippy happy! The easiest way:</p>
<ul>
<li>Commit your changes (so clippy can change safely).</li>
<li>Run <code>cargo clippy --fix</code> to do the easy changes automatically.</li>
<li>Run <code>cargo clippy</code> and take a look at the messages.</li>
</ul>
<p>Until now, I had no need to override or silence any clippy suggestions.</p>
<h3 id="shell"><a class="header" href="#shell">Shell</a></h3>
<p><code>shellcheck</code> lints all shell scripts. As they change very rarely, this is not
too important.</p>
<h2 id="unsafe-code"><a class="header" href="#unsafe-code">Unsafe code</a></h2>
<p>Any <code>unsafe</code> code is forbidden for now globally via <code>#![forbid(unsafe_code)]</code>.
I cannot think of any reason GRM may need <code>unsafe</code>. If it comes up, it needs to
be discussed.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>The documentation lives in the <code>docs</code> folder and uses
<a href="https://github.com/rust-lang/mdBook">mdBook</a>. Please document new user-facing
features here!</p>
<p>Using <a href="https://github.com/features/actions">GitHub actions</a>, the documentation
on <code>master</code> is automatically published to <a href="https://hakoerber.github.io/git-repo-manager/">the project
homepage</a> via GitHub pages. See
<code>.github/workflows/gh-pages.yml</code> for the configuration of GitHub Actions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
