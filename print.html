<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Git Repo Manager</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">2.</strong> Installation</a></li><li class="chapter-item expanded "><a href="repos.html"><strong aria-hidden="true">3.</strong> Repository trees</a></li><li class="chapter-item expanded "><a href="worktrees.html"><strong aria-hidden="true">4.</strong> Git Worktrees</a></li><li class="chapter-item expanded "><a href="forge_integration.html"><strong aria-hidden="true">5.</strong> Forge Integrations</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">6.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="contributing.html"><strong aria-hidden="true">7.</strong> Contributing</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Git Repo Manager</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Welcome! This is the documentation for <a href="https://github.com/hakoerber/git-repo-manager/">Git Repo
Manager</a> (GRM for short), a
tool that helps you manage git repositories.</p>
<p>GRM helps you manage git repositories in a declarative way. Configure your
repositories in a TOML or YAML file, GRM does the rest. Take a look at <a href="https://github.com/hakoerber/git-repo-manager/blob/master/example.config.toml">the
example
configuration</a>
to get a feel for the way you configure your repositories. See the <a href="./repos.html">repository
tree chapter</a> for details.</p>
<p>GRM also provides some tooling to work with single git repositories using
<code>git-worktree</code>. See <a href="./worktree.html">the worktree chapter</a> for more details.</p>
<h2 id="why-use-grm"><a class="header" href="#why-use-grm">Why use GRM?</a></h2>
<p>If you're working with a lot of git repositories, GRM can help you to manage them
in an easy way:</p>
<ul>
<li>You want to easily clone many repositories to a new machine.</li>
<li>You want to change remotes for multiple repositories (e.g. because your GitLab
domain changed).</li>
<li>You want to get an overview over all repositories you have, and check whether
you forgot to commit or push something.</li>
</ul>
<p>If you want to work with <a href="https://git-scm.com/docs/git-worktree">git worktrees</a>
in a streamlined, easy way, GRM provides you with an opinionated workflow. It's
especially helpful when the following describes you:</p>
<ul>
<li>You're juggling a lot of git branches, switching between them a lot.</li>
<li>When switching branches, you'd like to just leave your work as-is, without
using the stash or temporary commits.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>Building GRM currently requires the nightly Rust toolchain. The easiest way
is using <a href="https://rustup.rs/"><code>rustup</code></a>. Make sure that rustup is properly installed.</p>
<p>Make sure that the nightly toolchain is installed:</p>
<pre><code>$ rustup toolchain install nightly
</code></pre>
<p>Then, install the build dependencies:</p>
<table><thead><tr><th>Distribution</th><th>Command</th></tr></thead><tbody>
<tr><td>Archlinux</td><td><code>pacman -S --needed gcc openssl pkg-config</code></td></tr>
<tr><td>Ubuntu/Debian</td><td><code>apt-get install --no-install-recommends pkg-config gcc libssl-dev zlib1g-dev</code></td></tr>
</tbody></table>
<p>Then, it's a simple command to install the latest stable version:</p>
<pre><code class="language-bash">$ cargo +nightly install git-repo-manager
</code></pre>
<p>If you're brave, you can also run the development build:</p>
<pre><code class="language-bash">$ cargo +nightly install --git https://github.com/hakoerber/git-repo-manager.git --branch develop
</code></pre>
<h2 id="static-build"><a class="header" href="#static-build">Static build</a></h2>
<p>Note that by default, you will get a  dynamically linked executable.
Alternatively, you can also build a statically linked binary. For this, you
will need <code>musl</code> and a few other build dependencies installed installed:</p>
<table><thead><tr><th>Distribution</th><th>Command</th></tr></thead><tbody>
<tr><td>Archlinux</td><td><code>pacman -S --needed gcc musl perl make</code></td></tr>
<tr><td>Ubuntu/Debian</td><td><code>apt-get install --no-install-recommends gcc musl-tools libc-dev perl make</code></td></tr>
</tbody></table>
<p>(<code>perl</code> and <code>make</code> are required for the OpenSSL build script)</p>
<p>The, add the musl target via <code>rustup</code>:</p>
<pre><code>$ rustup +nightly target add x86_64-unknown-linux-musl
</code></pre>
<p>Then, use a modified build command to get a statically linked binary:</p>
<pre><code>$ cargo +nightly install git-repo-manager --target x86_64-unknown-linux-musl --features=static-build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-tree-of-git-repositories"><a class="header" href="#managing-tree-of-git-repositories">Managing tree of git repositories</a></h1>
<p>When managing multiple git repositories with GRM, you'll generally have a
configuration file containing information about all the repos you have. GRM then
makes sure that you repositories match that config. If they don't exist yet, it
will clone them. It will also make sure that all remotes are configured properly.</p>
<p>Let's try it out:</p>
<h2 id="get-the-example-configuration"><a class="header" href="#get-the-example-configuration">Get the example configuration</a></h2>
<pre><code class="language-bash">$ curl --proto '=https' --tlsv1.2 -sSfO https://raw.githubusercontent.com/hakoerber/git-repo-manager/master/example.config.toml
</code></pre>
<p>Then, you're ready to run the first sync. This will clone all configured repositories
and set up the remotes.</p>
<pre><code class="language-bash">$ grm repos sync config --config example.config.toml
[⚙] Cloning into &quot;/home/me/projects/git-repo-manager&quot; from &quot;https://code.hkoerber.de/hannes/git-repo-manager.git&quot;
[✔] git-repo-manager: Repository successfully cloned
[⚙] git-repo-manager: Setting up new remote &quot;github&quot; to &quot;https://github.com/hakoerber/git-repo-manager.git&quot;
[✔] git-repo-manager: OK
[⚙] Cloning into &quot;/home/me/projects/dotfiles&quot; from &quot;https://github.com/hakoerber/dotfiles.git&quot;
[✔] dotfiles: Repository successfully cloned
[✔] dotfiles: OK
</code></pre>
<p>If you run it again, it will report no changes:</p>
<pre><code>$ grm repos sync config -c example.config.toml
[✔] git-repo-manager: OK
[✔] dotfiles: OK
</code></pre>
<h3 id="generate-your-own-configuration"><a class="header" href="#generate-your-own-configuration">Generate your own configuration</a></h3>
<p>Now, if you already have a few repositories, it would be quite laborious to write
a configuration from scratch. Luckily, GRM has a way to generate a configuration
from an existing file tree:</p>
<pre><code class="language-bash">$ grm repos find local ~/your/project/root &gt; config.toml
</code></pre>
<p>This will detect all repositories and remotes and write them to <code>config.toml</code>.</p>
<h3 id="show-the-state-of-your-projects"><a class="header" href="#show-the-state-of-your-projects">Show the state of your projects</a></h3>
<pre><code class="language-bash">$ grm repos status --config example.config.toml
╭──────────────────┬──────────┬────────┬───────────────────┬────────┬─────────╮
│ Repo             ┆ Worktree ┆ Status ┆ Branches          ┆ HEAD   ┆ Remotes │
╞══════════════════╪══════════╪════════╪═══════════════════╪════════╪═════════╡
│ git-repo-manager ┆          ┆ ✔      ┆ branch: master    ┆ master ┆ github  │
│                  ┆          ┆        ┆ &lt;origin/master&gt; ✔ ┆        ┆ origin  │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌┤
│ dotfiles         ┆          ┆ ✔      ┆                   ┆ Empty  ┆ origin  │
╰──────────────────┴──────────┴────────┴───────────────────┴────────┴─────────╯
</code></pre>
<p>You can also use <code>status</code> without <code>--config</code> to check the repository you're currently
in:</p>
<pre><code>$ cd ~/example-projects/dotfiles
$ grm repos status
╭──────────┬──────────┬────────┬──────────┬───────┬─────────╮
│ Repo     ┆ Worktree ┆ Status ┆ Branches ┆ HEAD  ┆ Remotes │
╞══════════╪══════════╪════════╪══════════╪═══════╪═════════╡
│ dotfiles ┆          ┆ ✔      ┆          ┆ Empty ┆ origin  │
╰──────────┴──────────┴────────┴──────────┴───────┴─────────╯
</code></pre>
<h2 id="yaml"><a class="header" href="#yaml">YAML</a></h2>
<p>By default, the repo configuration uses TOML. If you prefer YAML, just give it
a YAML file instead (file ending does not matter, <code>grm</code> will figure out the format).
For generating a configuration, pass <code>--format yaml</code> to <code>grm repo find</code>
which generates a YAML config instead of a TOML configuration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-worktrees"><a class="header" href="#git-worktrees">Git Worktrees</a></h1>
<h2 id="why"><a class="header" href="#why">Why?</a></h2>
<p>The default workflow when using git is having your repository in a single directory.
Then, you can check out a certain reference (usually a branch), which will update
the files in the directory to match the state of that reference. Most of the time,
this is exactly what you need and works perfectly. But especially when you're working
with branches a lot, you may notice that there is a lot of work required to make
everything run smoothly.</p>
<p>Maybe you have experienced the following: You're working on a feature branch. Then,
for some reason, you have to change branches (maybe to investigate some issue).
But you get the following:</p>
<pre><code>error: Your local changes to the following files would be overwritten by checkout
</code></pre>
<p>Now you can create a temporary commit or stash your changes. In any case, you have
some mental overhead before you can work on something else. Especially with stashes,
you'll have to remember to do a <code>git stash pop</code> before resuming your work (I
cannot count the number of times where I &quot;rediscovered&quot; some code hidden in some
old stash I forgot about.</p>
<p>And even worse: If you're currently in the process of resolving merge conflicts or an
interactive rebase, there is just no way to &quot;pause&quot; this work to check out a
different branch.</p>
<p>Sometimes, it's crucial to have an unchanging state of your repository until some
long-running process finishes. I'm thinking of Ansible and Terraform runs. I'd
rather not change to a different branch while ansible or Terraform are running as
I have no idea how those tools would behave (and I'm not too eager to find out).</p>
<p>In any case, Git Worktrees are here for the rescue:</p>
<h2 id="what-are-git-worktrees"><a class="header" href="#what-are-git-worktrees">What are git worktrees?</a></h2>
<p><a href="https://git-scm.com/docs/git-worktree">Git Worktrees</a> allow you to have multiple
independent checkouts of your repository on different directories. You can have
multiple directories that correspond to different references in your repository.
Each worktree has it's independent working tree (duh) and index, so there is no
way to run into conflicts. Changing to a different branch is just a <code>cd</code> away (if
the worktree is already set up).</p>
<h2 id="worktrees-in-grm"><a class="header" href="#worktrees-in-grm">Worktrees in GRM</a></h2>
<p>GRM exposes an opinionated way to use worktrees in your repositories. Opinionated,
because there is a single invariant that makes reasoning about your worktree
setup quite easy:</p>
<p><strong>The branch inside the worktree is always the same as the directory name of the worktree.</strong></p>
<p>In other words: If you're checking out branch <code>mybranch</code> into a new worktree, the
worktree directory will be named <code>mybranch</code>.</p>
<p>GRM can be used with both &quot;normal&quot; and worktree-enabled repositories. But note
that a single repository can be either the former or the latter. You'll have to
decide during the initial setup which way you want to go for that repository.</p>
<p>If you want to clone your repository in a worktree-enabled way, specify
<code>worktree_setup = true</code> for the repository in your <code>config.toml</code>:</p>
<pre><code class="language-toml">[[trees.repos]]
name = &quot;git-repo-manager&quot;
worktree_setup = true
</code></pre>
<p>Now, when you run a <code>grm sync</code>, you'll notice that the directory of the repository
is empty! Well, not totally, there is a hidden directory called <code>.git-main-working-tree</code>.
This is where the repository actually &quot;lives&quot; (it's a bare checkout).</p>
<p>Note that there are few specific things you can configure for a certain
workspace.  This is all done in an optional <code>grm.toml</code> file right in the root
of the worktree. More on that later.</p>
<h3 id="creating-a-new-worktree"><a class="header" href="#creating-a-new-worktree">Creating a new worktree</a></h3>
<p>To actually work, you'll first have to create a new worktree checkout. All
worktree-related commands are available as subcommands of <code>grm worktree</code> (or
<code>grm wt</code> for short):</p>
<pre><code>$ grm wt add mybranch
[✔] Worktree mybranch created
</code></pre>
<p>You'll see that there is now a directory called <code>mybranch</code> that contains a checkout
of your repository, using the branch <code>mybranch</code></p>
<pre><code class="language-bash">$ cd ./mybranch &amp;&amp; git status
On branch mybranch
nothing to commit, working tree clean
</code></pre>
<p>You can work in this repository as usual. Make changes, commit them, revert them,
whatever you're up to :)</p>
<p>Just note that you <em>should</em> not change the branch inside the worktree
directory.  There is nothing preventing you from doing so, but you will notice
that you'll run into problems when trying to remove a worktree (more on that
later). It may also lead to confusing behaviour, as there can be no two
worktrees that have the same branch checked out. So if you decide to use the
worktree setup, go all in, let <code>grm</code> manage your branches and bury <code>git branch</code>
(and <code>git checkout -b</code>).</p>
<p>You will notice that there is no tracking branch set up for the new branch. You
can of course set up one manually after creating the worktree, but there is an
easier way, using the <code>--track</code> flag during creation. Let's create another
worktree. Go back to the root of the repository, and run:</p>
<pre><code class="language-bash">$ grm wt add mybranch2 --track origin/mybranch2
[✔] Worktree mybranch2 created
</code></pre>
<p>You'll see that this branch is now tracking <code>mybranch</code> on the <code>origin</code> remote:</p>
<pre><code class="language-bash">$ cd ./mybranch2 &amp;&amp; git status
On branch mybranch

Your branch is up to date with 'origin/mybranch2'.
nothing to commit, working tree clean
</code></pre>
<p>The behaviour of <code>--track</code> differs depending on the existence of the remote branch:</p>
<ul>
<li>If the remote branch already exists, <code>grm</code> uses it as the base of the new
local branch.</li>
<li>If the remote branch does not exist (as in our example), <code>grm</code> will create a
new remote tracking branch, using the default branch (either <code>main</code> or <code>master</code>)
as the base</li>
</ul>
<p>Often, you'll have a workflow that uses tracking branches by default. It would
be quite tedious to add <code>--track</code> every single time. Luckily, the <code>grm.toml</code> file
supports defaults for the tracking behaviour. See this for an example:</p>
<pre><code class="language-toml">[track]
default = true
default_remote = &quot;origin&quot;
</code></pre>
<p>This will set up a tracking branch on <code>origin</code> that has the same name as the local
branch.</p>
<p>Sometimes, you might want to have a certain prefix for all your tracking branches.
Maybe to prevent collissions with other contributors. You can simply set
<code>default_remote_prefix</code> in <code>grm.toml</code>:</p>
<pre><code class="language-toml">[track]
default = true
default_remote = &quot;origin&quot;
default_remote_prefix = &quot;myname&quot;
</code></pre>
<p>When using branch <code>my-feature-branch</code>, the remote tracking branch would be
<code>origin/myname/my-feature-branch</code> in this case.</p>
<p>Note that <code>--track</code> overrides any configuration in <code>grm.toml</code>. If you want to
disable tracking, use <code>--no-track</code>.</p>
<h3 id="showing-the-status-of-your-worktrees"><a class="header" href="#showing-the-status-of-your-worktrees">Showing the status of your worktrees</a></h3>
<p>There is a handy little command that will show your an overview over all worktrees
in a repository, including their status (i.e. changes files). Just run the following
in the root of your repository:</p>
<pre><code>$ grm wt status
╭───────────┬────────┬──────────┬──────────────────╮
│ Worktree  ┆ Status ┆ Branch   ┆ Remote branch    │
╞═══════════╪════════╪══════════╪══════════════════╡
│ mybranch  ┆ ✔      ┆ mybranch ┆                  │
│ mybranch2 ┆ ✔      ┆ mybranch ┆ origin/mybranch2 │
╰───────────┴────────┴──────────┴──────────────────╯
</code></pre>
<p>The &quot;Status&quot; column would show any uncommitted changes (new / modified / deleted
files) and the &quot;Remote branch&quot; would show differences to the remote branch (e.g.
if there are new pushes to the remote branch that are not yet incorporated into
your local branch).</p>
<h3 id="deleting-worktrees"><a class="header" href="#deleting-worktrees">Deleting worktrees</a></h3>
<p>If you're done with your worktrees, use <code>grm wt delete</code> to delete them. Let's
start with <code>mybranch2</code>:</p>
<pre><code>$ grm wt delete mybranch2
[✔] Worktree mybranch2 deleted
</code></pre>
<p>Easy. On to <code>mybranch</code>:</p>
<pre><code>$ grm wt delete mybranch
[!] Changes in worktree: No remote tracking branch for branch mybranch found. Refusing to delete
</code></pre>
<p>Hmmm. <code>grm</code> tells you:</p>
<p>&quot;Hey, there is no remote branch that you could have pushed
your changes to. I'd rather not delete work that you cannot recover.&quot;</p>
<p>Note that <code>grm</code> is very cautious here. As your repository will not be deleted,
you could still recover the commits via <a href="https://git-scm.com/docs/git-reflog"><code>git-reflog</code></a>.
But better safe than sorry! Note that you'd get a similar error message if your
worktree had any uncommitted files, for the same reason. Now you can either
commit &amp; push your changes, or your tell <code>grm</code> that you know what you're doing:</p>
<pre><code>$ grm wt delete mybranch --force
[✔] Worktree mybranch deleted
</code></pre>
<p>If you just want to delete all worktrees that do not contain any changes, you
can also use the following:</p>
<pre><code>$ grm wt clean
</code></pre>
<p>Note that this will not delete the default branch of the repository. It can of
course still be delete with <code>grm wt delete</code> if neccessary.</p>
<h3 id="persistent-branches"><a class="header" href="#persistent-branches">Persistent branches</a></h3>
<p>You most likely have a few branches that are &quot;special&quot;, that you don't want to
clean up and that are the usual target for feature branches to merge into. GRM
calls them &quot;persistent branches&quot; and treats them a bit differently:</p>
<ul>
<li>Their worktrees will never be deleted by <code>grm wt clean</code></li>
<li>If the branches in other worktrees are merged into them, they will be cleaned
up, even though they may not be in line with their upstream. Same goes for
<code>grm wt delete</code>, which will not require a <code>--force</code> flag. Note that of
course, actual changes in the worktree will still block an automatic cleanup!</li>
<li>As soon as you enable persistent branches, non-persistent branches will only
ever be cleaned up when merged into a persistent branch.</li>
</ul>
<p>To elaborate: This is mostly relevant for a feature-branch workflow. Whenever a
feature branch is merged, it can usually be thrown away. As merging is usually
done on some remote code management platform (GitHub, GitLab, ...), this means
that you usually keep a branch around until it is merged into one of the &quot;main&quot;
branches (<code>master</code>, <code>main</code>, <code>develop</code>, ...)</p>
<p>Enable persistent branches by setting the following in the <code>grm.toml</code> in the
worktree root:</p>
<pre><code class="language-toml">persistent_branches = [
    &quot;master&quot;,
    &quot;develop&quot;,
]
</code></pre>
<p>Note that setting persistent branches will disable any detection of &quot;default&quot;
branches. The first entry will be considered your repositories' default branch.</p>
<h3 id="converting-an-existing-repository"><a class="header" href="#converting-an-existing-repository">Converting an existing repository</a></h3>
<p>It is possible to convert an existing directory to a worktree setup, using <code>grm wt convert</code>. This command has to be run in the root of the repository you want
to convert:</p>
<pre><code>$ grm wt convert
[✔] Conversion successful
</code></pre>
<p>This command will refuse to run if you have any changes in your repository.
Commit them and try again!</p>
<p>Afterwards, the directory is empty, as there are no worktrees checked out yet.
Now you can use the usual commands to set up worktrees.</p>
<h3 id="working-with-remotes"><a class="header" href="#working-with-remotes">Working with remotes</a></h3>
<p>To fetch all remote references from all remotes in a worktree setup, you can
use the following command:</p>
<pre><code>$ grm wt fetch
[✔] Fetched from all remotes
</code></pre>
<p>This is equivalent to running <code>git fetch --all</code> in any of the worktrees.</p>
<p>Often, you may want to pull all remote changes into your worktrees. For this,
use the <code>git pull</code> equivalent:</p>
<pre><code>$ grm wt pull
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>This will refuse when there are local changes, or if the branch cannot be fast
forwarded. If you want to rebase your local branches, use the <code>--rebase</code> switch:</p>
<pre><code>$ grm wt pull --rebase
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>As noted, this will fail if there are any local changes in your worktree. If you
want to stash these changes automatically before the pull (and unstash them
afterwards), use the <code>--stash</code> option.</p>
<p>This will rebase your changes onto the upstream branch. This is mainly helpful
for persistent branches that change on the remote side.</p>
<p>There is a similar rebase feature that rebases onto the <strong>default</strong> branch instead:</p>
<pre><code>$ grm wt rebase
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>This is super helpful for feature branches. If you want to incorporate changes
made on the remote branches, use <code>grm wt rebase</code> and all your branches will
be up to date. If you want to also update to remote tracking branches in one go,
use the <code>--pull</code> flag, and <code>--rebase</code> if you want to rebase instead of aborting
on non-fast-forwards:</p>
<pre><code>$ grm wt rebase --pull --rebase
[✔] master: Done
[✔] my-cool-branch: Done
</code></pre>
<p>&quot;So, what's the difference between <code>pull --rebase</code> and <code>rebase --pull</code>? Why the
hell is there a <code>--rebase</code> flag in the <code>rebase</code> command?&quot;</p>
<p>Yes, it's kind of weird. Remember that <code>pull</code> only ever updates each worktree
to their remote branch, if possible. <code>rebase</code> rebases onto the <strong>default</strong> branch
instead. The switches to <code>rebase</code> are just convenience, so you do not have to
run two commands.</p>
<ul>
<li><code>rebase --pull</code> is the same as <code>pull</code> &amp;&amp; <code>rebase</code></li>
<li><code>rebase --pull --rebase</code> is the same as <code>pull --rebase</code> &amp;&amp; <code>rebase</code></li>
</ul>
<p>I understand that the UX is not the most intuitive. If you can think of an
improvement, please let me know (e.g. via an GitHub issue)!</p>
<p>As with <code>pull</code>, <code>rebase</code> will also refuse to run when there are changes in your
worktree. And you can also use the <code>--stash</code> option to stash/unstash changes
automatically.</p>
<h3 id="manual-access"><a class="header" href="#manual-access">Manual access</a></h3>
<p>GRM isn't doing any magic, it's just git under the hood. If you need to have access
to the underlying git repository, you can always do this:</p>
<pre><code>$ git --git-dir ./.git-main-working-tree [...]
</code></pre>
<p>This should never be required (whenever you have to do this, you can consider
this a bug in GRM and open an <a href="https://github.com/hakoerber/git-repo-manager/issues/new">issue</a>,
but it may help in a pinch.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forge-integrations"><a class="header" href="#forge-integrations">Forge Integrations</a></h1>
<p>In addition to manging repositories locally, <code>grm</code> also integrates with source
code hosting platforms. Right now, the following platforms are supported:</p>
<ul>
<li><a href="https://github.com/">GitHub</a></li>
<li><a href="https://gitlab.com/">GitLab</a></li>
</ul>
<p>Imagine you are just starting out with <code>grm</code> and want to clone all your repositories
from GitHub. This is as simple as:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --owner --token-command &quot;pass show github_grm_access_token&quot; --path ~/projects
</code></pre>
<p>You will end up with your projects cloned into <code>~/projects/{your_github_username}/</code></p>
<h2 id="authentication"><a class="header" href="#authentication">Authentication</a></h2>
<p>The only currently supported authentication option is using a personal access
token.</p>
<h3 id="github"><a class="header" href="#github">GitHub</a></h3>
<p>See the GitHub documentation for personal access tokens:
<a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/creating-a-personal-access-token">Link</a>.</p>
<p>The only required permission is the &quot;repo&quot; scope.</p>
<h3 id="gitlab"><a class="header" href="#gitlab">GitLab</a></h3>
<p>See the GitLab documentation for personal access tokens:
<a href="https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html">Link</a>.</p>
<p>The required scopes are a bit weird. Actually, the following should suffice:</p>
<ul>
<li>
<ul>
<li><code>read_user</code> to get user information (required to get the current authenticated
user name for the <code>--owner</code> filter.</li>
</ul>
</li>
<li>A scope that allows reading private repositories. (<code>read_repository</code> is just
for <em>cloning</em> private repos). This unfortunately does not exist.</li>
</ul>
<p>So currently, you'll need to select the <code>read_api</code> scope.</p>
<h2 id="filters"><a class="header" href="#filters">Filters</a></h2>
<p>By default, <code>grm</code> will sync <strong>nothing</strong>. This is quite boring, so you have to
tell the command what repositories to include. They are all inclusive (i.e. act
as a logical OR), so you can easily chain many filters to clone a bunch of
repositories. It's quite simple:</p>
<ul>
<li><code>--user &lt;USER&gt;</code> syncs all repositories of that remote user</li>
<li><code>--group &lt;GROUP&gt;</code> syncs all repositories of that remote group/organization</li>
<li><code>--owner</code> syncs all repositories of the user that is used for authentication.
This is effectively a shortcut for <code>--user $YOUR_USER</code></li>
<li><code>--access</code> syncs all repositories that the current user has access to</li>
</ul>
<p>Easiest to see in an example:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --user torvals --owner --group zalando [...]
</code></pre>
<p>This would sync all of Torvald's repositories, all of my own repositories and
all (public) repositories in the &quot;zalando&quot; group.</p>
<h2 id="strategies"><a class="header" href="#strategies">Strategies</a></h2>
<p>There are generally three ways how you can use <code>grm</code> with forges:</p>
<h3 id="ad-hoc-cloning"><a class="header" href="#ad-hoc-cloning">Ad-hoc cloning</a></h3>
<p>This is the easiest, there are no local files involved. You just run the
command, <code>grm</code> clones the repos, that's it. If you run the command again, <code>grm</code>
will figure out the differences between local and remote repositories and
resolve them locally.</p>
<h3 id="create-a-file"><a class="header" href="#create-a-file">Create a file</a></h3>
<p>This is effectively <code>grm repos find local</code>, but using the forge instead of the
local file system. You will end up with a normal repository file that you can
commit to git. To update the list of repositories, just run the command again
and commit the new file.</p>
<h3 id="define-options-in-a-file"><a class="header" href="#define-options-in-a-file">Define options in a file</a></h3>
<p>This is a hybrid approach: You define filtering options in a file that you can
commit to source control. Effectively, you are persisting the options you gave
to <code>grm</code> on the command line with the ad-hoc approach. Similarly, <code>grm</code> will
figure out differences between local and remote and resolve them.</p>
<p>A file would look like this:</p>
<pre><code class="language-toml">provider = &quot;github&quot;
token_command = &quot;cat ~/.github_token&quot;
root = &quot;~/projects&quot;

[filters]
owner = true
groups = [
  &quot;zalando&quot;
]
</code></pre>
<p>The options in the file map to the command line options of the <code>grm repos sync remote</code> command.</p>
<p>You'd then run the <code>grm repos sync</code> command the same way as with a list of
repositories in a config:</p>
<pre><code class="language-bash">$ grm repos sync --config example.config.toml
</code></pre>
<p>You can even use that file to generate a repository list that you can feed into
<code>grm repos sync</code>:</p>
<pre><code class="language-bash">$ grm repos find config --config example.config.toml &gt; repos.toml
$ grm repos sync config --config repos.toml
</code></pre>
<h2 id="using-with-selfhosted-gitlab"><a class="header" href="#using-with-selfhosted-gitlab">Using with selfhosted GitLab</a></h2>
<p>By default, <code>grm</code> uses the default GitLab API endpoint
(<a href="https://gitlab.com">https://gitlab.com</a>). You can override the
endpoint by specifying the <code>--api-url</code> parameter. Like this:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider gitlab --api-url https://gitlab.example.com [...]
</code></pre>
<h2 id="the-cloning-protocol"><a class="header" href="#the-cloning-protocol">The cloning protocol</a></h2>
<p>By default, <code>grm</code> will use HTTPS for public repositories and SSH otherwise. This
can be overridden with the <code>--force-ssh</code> switch.</p>
<h2 id="about-the-token-command"><a class="header" href="#about-the-token-command">About the token command</a></h2>
<p>To ensure maximum flexibility, <code>grm</code> has a single way to get the token it uses
to authenticate: Specify a command that returns the token via stdout. This easily
integrates with password managers like <a href="https://www.passwordstore.org/"><code>pass</code></a>.</p>
<p>Of course, you are also free to specify something like <code>echo mytoken</code> as the
command, as long as you are ok with the security implications (like having the
token in cleartext in your shell history). It may be better to have the token
in a file instead and read it: <code>cat ~/.gitlab_token</code>.</p>
<p>Generally, use whatever you want. The command just has to return sucessfully and
return the token as the first line of stdout.</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Maybe you just want to locally clone all repos from your github user?</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --owner --root ~/github_projects --token-command &quot;pass show github_grm_access_token&quot;
</code></pre>
<p>This will clone all repositories into <code>~/github_projects/{your_github_username}</code>.</p>
<p>If instead you want to clone <strong>all</strong> repositories you have access to (e.g. via
organizations or other users' private repos you have access to), just change the
filter a little bit:</p>
<pre><code class="language-bash">$ grm repos sync remote --provider github --access --root ~/github_projects --token-command &quot;pass show github_grm_access_token&quot;
</code></pre>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="github-1"><a class="header" href="#github-1">GitHub</a></h3>
<p>Unfortunately, GitHub does not have a nice API endpoint to get <strong>private</strong>
repositories for a certain user (<a href="https://docs.github.com/en/rest/repos/repos#list-repositories-for-a-user"><code>/users/{user}/repos/</code></a> only returns public
repositories).</p>
<p>Therefore, using <code>--user {user}</code> will only show public repositories for GitHub.
Note that this does not apply to <code>--access</code>: If you have access to another user's
private repository, it will be listed.</p>
<h2 id="adding-integrations"><a class="header" href="#adding-integrations">Adding integrations</a></h2>
<p>Adding a new integration involves writing some Rust code. Most of the logic is
generic, so you will not have to reinvent the wheel. Generally, you will need to
gather the following information:</p>
<ul>
<li>A list of repositories for a single user</li>
<li>A list of repositories for a group (or any similar concept if applicable)</li>
<li>A list of repositories for the user that the API token belongs to</li>
<li>The username of the currently authenticated user</li>
</ul>
<p>Authentication currently only works via a bearer token passed via the
<code>Authorization</code> HTTP header.</p>
<p>Each repo has to have the following properties:</p>
<ul>
<li>A name (which also acts as the identifier for diff between local and remote
repositories)</li>
<li>An SSH url to push to</li>
<li>An HTTPS url to clone and fetch from</li>
<li>A flag that marks the repository as private</li>
</ul>
<p>If you plan to implement another forge, please first open an issue so we can
go through the required setup. I'm happy to help!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="why-is-the-nightly-toolchain-required"><a class="header" href="#why-is-the-nightly-toolchain-required">Why is the nightly toolchain required?</a></h2>
<p>Building GRM currently requires nightly features due to the usage of
<a href="https://doc.rust-lang.org/std/fs/struct.FileType.html#method.is_symlink"><code>std::path::Path::is_symlink()</code></a>.
See the <a href="https://github.com/rust-lang/rust/issues/85748">tracking issue</a>.</p>
<p><code>is_symlink()</code> is actually available in rustc 1.57, so it will be on stable in
the near future. This would mean that GRM can be built using the stable toolchain!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>GRM is still in very early development. I started GRM mainly to scratch my own
itches (and am heavily dogfooding it). If you have a new use case for GRM, go
for it!</p>
<p>The branching strategy is a simplified
<a href="https://nvie.com/posts/a-successful-git-branching-model/">git-flow</a>.</p>
<ul>
<li><code>master</code> is the &quot;production&quot; branch. Each commit is a new release.</li>
<li><code>develop</code> is the branch where new stuff is coming in.</li>
<li>feature branches branch off of <code>develop</code> and merge back into it.</li>
</ul>
<p>So to contribute, just fork the repo and create a pull request against
<code>develop</code>. If you plan bigger changes, please consider opening an issue first,
so we can discuss it.</p>
<p>If you want, add yourself to the <code>CONTRIBUTORS</code> file in your pull request.</p>
<h2 id="code-formatting"><a class="header" href="#code-formatting">Code formatting</a></h2>
<p>For Rust, just use <code>cargo fmt</code>. For Python, use
<a href="https://github.com/psf/black">black</a>. I'd rather not spend any effort in
configuring the formatters (not possible for black anyway).</p>
<h2 id="tooling"><a class="header" href="#tooling">Tooling</a></h2>
<p>GRM uses <a href="https://github.com/casey/just"><code>just</code></a> as a command runner. See
<a href="https://github.com/casey/just#installation">here</a> for installation
instructions (it's most likely just a simple <code>cargo install just</code>).</p>
<h2 id="testing"><a class="header" href="#testing">Testing</a></h2>
<p>There are two distinct test suites: One for unit test (<code>just test-unit</code>) and
integration tests (<code>just test-integration</code>) that is part of the rust crate, and
a separate e2e test suite in python (<code>just test-e2e</code>).</p>
<p>To run all tests, run <code>just test</code>.</p>
<p>When contributing, consider whether it makes sense to add tests which could
prevent regressions in the future. When fixing bugs, it makes sense to add
tests that expose the wrong behaviour beforehand.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>The documentation lives in <code>docs</code> and uses
<a href="https://github.com/rust-lang/mdBook">mdBook</a>. Please document new user-facing
features here!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
    </body>
</html>
